div(id='player', class='flex-centered')
div(class='not-flex-centered')
  div(class='row')
    div(class='col-md-2')
    form(class='form-group', id='play_video', action='')
      div(class='col-md-5')
        input(class='form-control', id='video_id',
          style='margin:0 0 10px 0;',
          placeholder='Search for a video or enter an ID or URL')
      div(class='col-md-2')
        button(class='btn btn-default') Submit
      div(class='col-md-2')
        button(class='btn btn-default', id='mute')
          span(id='mute-icon', class='glyphicon glyphicon-volume-up',
               aria-hidden='true')
script.

  var my_video_state = {};
  var current_search_results = [];
  var MAX_RESULTS = 7;
  var MAX_PRETTY_LEN = 60;

  // e.g. "michelleheafy: Some cool video about someth..."
  function prettify_result(result) {
    var artist = result.snippet.channelTitle
    var pretty = artist + ": " + result.snippet.title;
    if (pretty.length > MAX_PRETTY_LEN) {
      pretty = pretty.slice(0, MAX_PRETTY_LEN - 3) + "...";
    }
    return pretty
  }

  // Take in youtube search result items and turn them into an array of objects
  // that autocomplete can handle, truncating the list in the process
  function transform_search_results(results) {
    return results.slice(0, MAX_RESULTS).map(function(result) {
      return {
        label: prettify_result(result),
        value: result.id.videoId
      }
    });
  }

  // As the user types in a video, send video search requests to the server
  // TODO do this from the client
  $('#video_id').on('input', function(e) {
    var query = $(e.target).context.value;
    console.log('sending video search to server:', query);
    socket.emit('video search', query);
    return false;
  });

  $('#video_id').autocomplete({
    source: function(request, response) {
      response(current_search_results);
    },
    focus: function(event, ui) {
      console.log('focus', ui);
      console.log(event);
      $('#video_id').val(ui.item.label);
      return false;
    },
    select: function(event, ui) {
      var event = jQuery.Event("submit");
      event.video_id = ui.item.value;
      $('#play_video').trigger(event);
      return false;
    }
  });

  // When the server sends us search results, update our local map and show
  // them to the user
  socket.on('video search', function(results) {
    current_search_results = transform_search_results(results);
  });

  // Client text box for submitting a video
  $('#play_video').submit(function(event) {
    // We might have been invoked straight from an autocomplete callback,
    // in which case the value of the search box is not the video id; it's
    // a pretty label, and the video id was passed in with the event.
    var video_id = event.video_id;

    console.log('passed-in video_id from event:', video_id);
    if (video_id == undefined) {
      video_id = $('#video_id').val();
    }

    // Accept URLs
    if (video_id.starts_with('https:\/\/www.youtube.com')) {
      console.log('url entered');
      video_id = video_id.split('watch?v=').slice(-1);
    }

    // TODO verify that it's a valid ID before submitting
    var new_video_state = {
      user: get_cookie('username'),
      video_id: video_id
    }
    socket.emit('video submit', new_video_state);
    $('#video_id').val('');
    return false;
  });

  // Start the specified video, starting at the correct time
  function apply_video_state(state) {
    id =  state['id'];
    start_time =  state['start_time'];
    user = state['user'];
    if (my_video_state['id'] != id ||
        my_video_state['start_time'] != start_time) {
      my_video_state = {
        user: user,
        id: id,
        start_time: start_time
      };
      video_progress = (state['server_time'] - start_time) / 1000;
      console.log("apply video state", id, video_progress);
      player.loadVideoById({
        'videoId': id,
        'startSeconds': video_progress,
        'suggestedQuality': 'large'
      });
    }
  }

  // Server tells us about video state changes
  socket.on('video state', function(video_state) {
    apply_video_state(video_state);
  });

  // Mute button
  $('#mute').on('click', function(e) {
    e.preventDefault();
    if (player.isMuted()) {
      player.unMute();
      $('#mute-icon').attr('class', 'glyphicon glyphicon-volume-up');
    }
    else {
      player.mute();
      $('#mute-icon').attr('class', 'glyphicon glyphicon-volume-off');
    }
    return false;
  });

  // Load the IFrame Player API code, asynchronously
  var tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

  // Create an <iframe> (and YouTube player) after the API code downloads.
  var player;
  function onYouTubeIframeAPIReady() {
    player = new YT.Player('player', {
      height: '390',
      width: '640',
      playerVars: {
        'autoplay': 0,
        'autohide': 1,
        'controls': 0,
        'rel': 0,
        'disablekb': 1,
        'modestbranding': 1,
        // TODO add 'origin' param; set it to my domain
        'iv_load_policy': 0
      },
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
      }
    });
  }

  // The API will call this function when the video player is ready.
  function onPlayerReady(event) {
    player.unMute();
    socket.emit('video state', 0);
  }

  // The API calls this function when the player's state changes.
  // The function indicates that when playing a video (state=1),
  // the player should play for six seconds and then stop.
  var done = false;
  function onPlayerStateChange(event) {
    console.log("player state change:", event.data)
    if (event.data == YT.PlayerState.PAUSED) {
      event.target.playVideo(); // TODO does this violate the youtube ToS?
    }
  }


